<br>
<div class="alert alert-info" role="alert">
    <i class="fa fa-exclamation-triangle"></i><b> Note:</b> Starting with v0.12.0, Prometheus Operator requires use of Kubernetes v1.7.x and up.
</div>

<h1 id="FAQ-Troubleshooting"><a href="#FAQ-Troubleshooting" class="headerlink" title="FAQ / Troubleshooting"></a>FAQ / Troubleshooting</h1><h3 id="RBAC-on-Google-Container-Engine-GKE"><a href="#RBAC-on-Google-Container-Engine-GKE" class="headerlink" title="RBAC on Google Container Engine (GKE)"></a>RBAC on Google Container Engine (GKE)</h3><p>When you try to create <code>ClusterRole</code> (<code>kube-state-metrics</code>, <code>prometheus</code> <code>prometheus-operator</code>, etc.) on GKE Kubernetes cluster running 1.6 version, you will probably run into permission errors:</p>
<pre><code>&lt;....&gt;
Error from server (Forbidden): error when creating 
&quot;manifests/prometheus-operator/prometheus-operator-cluster-role.yaml&quot;: 
clusterroles.rbac.authorization.k8s.io &quot;prometheus-operator&quot; is forbidden: attempt to grant extra privileges:
&lt;....&gt;</code></pre>
<p>This is due to the way Container Engine checks permissions. From <a href="https://cloud.google.com/kubernetes-engine/docs/how-to/role-based-access-control">Google Kubernetes Engine docs</a>:</p>
<blockquote>
<p>Because of the way Container Engine checks permissions when you create a Role or ClusterRole, you must first create a RoleBinding that grants you all of the permissions included in the role you want to create.<br>An example workaround is to create a RoleBinding that gives your Google identity a cluster-admin role before attempting to create additional Role or ClusterRole permissions.<br>This is a known issue in the Beta release of Role-Based Access Control in Kubernetes and Container Engine version 1.6.</p>
</blockquote>
<p>To overcome this, you must grant your current Google identity <code>cluster-admin</code> Role:</p>
<pre><code class="console"># get current google identity
$ gcloud info | grep Account
Account: [myname@example.org]

# grant cluster-admin to your current identity
$ kubectl create clusterrolebinding myname-cluster-admin-binding --clusterrole=cluster-admin --user=myname@example.org
Clusterrolebinding &quot;myname-cluster-admin-binding&quot; created</code></pre>
<h3 id="Troubleshooting-ServiceMonitor-changes"><a href="#Troubleshooting-ServiceMonitor-changes" class="headerlink" title="Troubleshooting ServiceMonitor changes"></a>Troubleshooting ServiceMonitor changes</h3><p>When creating/deleting/modifying <code>ServiceMonitor</code> objects it is sometimes not as obvious what piece is not working properly. This section gives a step by step guide how to troubleshoot such actions on a <code>ServiceMonitor</code> object.</p>
<h4 id="Overview-of-ServiceMonitor-tagging-and-related-elements"><a href="#Overview-of-ServiceMonitor-tagging-and-related-elements" class="headerlink" title="Overview of ServiceMonitor tagging and related elements"></a>Overview of <code>ServiceMonitor</code> tagging and related elements</h4><p>A common problem related to <code>ServiceMonitor</code> identification by Prometheus is related to an incorrect tagging, that does not match the <code>Prometheus</code> custom resource definition scope, or lack of permission for the Prometheus <code>ServiceAccount</code> to <em>get, list, watch</em> <code>Services</code> and <code>Endpoints</code> from the target application being monitored. As a general guideline consider the diagram below, giving an example of a <code>Deployment</code> and <code>Service</code> called <code>my-app</code>, being monitored by Prometheus based on a <code>ServiceMonitor</code> named <code>my-service-monitor</code>:</p>
<p><img src="custom-metrics-elements.png" alt="flow diagram"></p>
<p>Note: The <code>ServiceMonitor</code> references a <code>Service</code> (not a <code>Deployment</code>, or a <code>Pod</code>), by labels <em>and</em> by the port name in the <code>Service</code>. This <em>port name</em> is optional in Kubernetes, but must be specified for the <code>ServiceMonitor</code> to work. It is not the same as the port name on the <code>Pod</code> or container, although it can be.</p>
<h4 id="Has-my-ServiceMonitor-been-picked-up-by-Prometheus"><a href="#Has-my-ServiceMonitor-been-picked-up-by-Prometheus" class="headerlink" title="Has my ServiceMonitor been picked up by Prometheus?"></a>Has my <code>ServiceMonitor</code> been picked up by Prometheus?</h4><p><code>ServiceMonitor</code> objects are selected by the <code>serviceMonitorSelector</code> of a Prometheus object. The name of a <code>ServiceMonitor</code> is encoded in the Prometheus configuration, so you can simply grep whether it is present there. The configuration generated by the Prometheus Operator is stored in a Kubernetes <code>Secret</code>, named after the Prometheus object name prefixed with <code>prometheus-</code> and is located in the same namespace as the Prometheus object. For example for a Prometheus object called <code>k8s</code> one can find out if the <code>ServiceMonitor</code> named <code>my-service-monitor</code> has been picked up with:</p>
<pre><code>kubectl -n monitoring get secret prometheus-k8s -ojson | jq -r &#39;.data[&quot;prometheus.yaml.gz&quot;]&#39; | base64 -d | gunzip | grep &quot;my-service-monitor&quot;</code></pre>
<h3 id="Prometheus-kubelet-metrics-server-returned-HTTP-status-403-Forbidden"><a href="#Prometheus-kubelet-metrics-server-returned-HTTP-status-403-Forbidden" class="headerlink" title="Prometheus kubelet metrics server returned HTTP status 403 Forbidden"></a>Prometheus kubelet metrics server returned HTTP status 403 Forbidden</h3><p>Prometheus is installed, all looks good, however the <code>Targets</code> are all showing as down. All permissions seem to be good, yet no joy. Prometheus pulling metrics from all namespaces expect kube-system, and Prometheus has access to all namespaces including kube-system.</p>
<h4 id="Did-you-check-the-webhooks"><a href="#Did-you-check-the-webhooks" class="headerlink" title="Did you check the webhooks?"></a>Did you check the webhooks?</h4><p>Issue has been resolved by amending the webhooks to use <code>0.0.0.0</code> instead of <code>127.0.0.1</code>. Follow the below commands and it will update the webhooks which allows connections to all <code>clusterIP&#39;s</code>  in all <code>namespaces</code> and not just <code>127.0.0.1</code>.</p>
<p><strong>Update the kubelet service to include webhook and restart:</strong></p>
<pre><code>KUBEADM_SYSTEMD_CONF=/etc/systemd/system/kubelet.service.d/10-kubeadm.conf
sed -e &quot;/cadvisor-port=0/d&quot; -i &quot;$KUBEADM_SYSTEMD_CONF&quot;
if ! grep -q &quot;authentication-token-webhook=true&quot; &quot;$KUBEADM_SYSTEMD_CONF&quot;; then
  sed -e &quot;s/--authorization-mode=Webhook/--authentication-token-webhook=true --authorization-mode=Webhook/&quot; -i &quot;$KUBEADM_SYSTEMD_CONF&quot;
fi
systemctl daemon-reload
systemctl restart kubelet</code></pre>
<p><strong>Modify the kube controller and kube scheduler to allow for reading data:</strong></p>
<pre><code>sed -e &quot;s/- --address=127.0.0.1/- --address=0.0.0.0/&quot; -i /etc/kubernetes/manifests/kube-controller-manager.yaml
sed -e &quot;s/- --address=127.0.0.1/- --address=0.0.0.0/&quot; -i /etc/kubernetes/manifests/kube-scheduler.yaml</code></pre>
<h3 id="Using-textual-port-number-instead-of-port-name"><a href="#Using-textual-port-number-instead-of-port-name" class="headerlink" title="Using textual port number instead of port name"></a>Using textual port number instead of port name</h3><p>The ServiceMonitor expects to use the port name as defined on the Service. So, using the Service example from the<br>diagram above, we have this Service definition:</p>
<pre><code>kind: Service
metadata:
  labels:
    k8s-app: my-app
  name: my-app
...
  spec:
    ports:
      - name: metrics
        port: 8080
    selector:
      k8s-app: my-app</code></pre>
<p>We would then define the service monitor using <code>metrics</code> as the port not <code>&quot;8080&quot;</code>. E.g.</p>
<p><strong>CORRECT</strong></p>
<pre><code>kind: ServiceMonitor
metadata:
  name: my-app
spec:
...
  endpoints:
    - port: metrics</code></pre>
<p><strong>INCORRECT</strong></p>
<pre><code>kind: ServiceMonitor
metadata:
  name: my-app
spec:
...
  endpoints:
    - port: &quot;8080&quot;</code></pre>
<p>The incorrect example will give an error along these lines <code>spec.endpoints.port in body must be of type string: &quot;integer&quot;</code></p>
