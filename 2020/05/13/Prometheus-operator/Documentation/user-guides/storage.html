<br>
<div class="alert alert-info" role="alert">
    <i class="fa fa-exclamation-triangle"></i><b> Note:</b> Starting with v0.12.0, Prometheus Operator requires use of Kubernetes v1.7.x and up.
</div>

<h1 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h1><p>To maintain data across deployments and version upgrades, the data must be persisted to some volume other than <code>emptyDir</code>, allowing it to be reused by Pods after an upgrade.</p>
<p>Kubernetes supports several kinds of storage volumes. The Prometheus Operator works with PersistentVolumeClaims, which support the underlying PersistentVolume to be provisioned when requested.</p>
<p>This document assumes a basic understanding of PersistentVolumes, PersistentVolumeClaims, and their <a href="https://kubernetes.io/docs/user-guide/persistent-volumes/#provisioning">provisioning</a>.</p>
<h2 id="Storage-Provisioning-on-AWS"><a href="#Storage-Provisioning-on-AWS" class="headerlink" title="Storage Provisioning on AWS"></a>Storage Provisioning on AWS</h2><p>Automatic provisioning of storage requires a <code>StorageClass</code>.</p>
<pre><code class="yaml">apiVersion: storage.k8s.io/v1beta1
kind: StorageClass
metadata:
  name: ssd
provisioner: kubernetes.io/aws-ebs
parameters:
  type: gp2</code></pre>
<blockquote>
<p>Make sure that AWS as a cloud provider is properly configured with your cluster, or storage provisioning will not work.</p>
</blockquote>
<p>For best results, use volumes that have high I/O throughput. These examples use SSD EBS volumes. Read the Kubernetes <a href="https://kubernetes.io/docs/user-guide/persistent-volumes/#aws">Persistent Volumes</a> documentation to adapt this <code>StorageClass</code> to your needs.</p>
<p>The <code>StorageClass</code> that was created can be specified in the <code>storage</code> section in the <code>Prometheus</code> resource (note that if youâ€™re using <a href="https://github.com/coreos/kube-prometheus">kube-prometheus</a>, then instead of making the following change to your <code>Prometheus</code> resource, see the <a href="https://github.com/coreos/kube-prometheus/blob/master/examples/prometheus-pvc.jsonnet">prometheus-pvc.jsonnet</a> example).</p>
<pre><code class="yaml">apiVersion: monitoring.coreos.com/v1
kind: Prometheus
metadata:
  name: persisted
spec:
  storage:
    volumeClaimTemplate:
      spec:
        storageClassName: ssd
        resources:
          requests:
            storage: 40Gi</code></pre>
<blockquote>
<p>The full documentation of the <code>storage</code> field can be found in the <a href="../api.md#storagespec">API documentation</a>.</p>
</blockquote>
<p>When creating the Prometheus object, a PersistentVolumeClaim is used for each Pod in the StatefulSet, and the storage should automatically be provisioned, mounted and used.</p>
<h2 id="Manual-storage-provisioning"><a href="#Manual-storage-provisioning" class="headerlink" title="Manual storage provisioning"></a>Manual storage provisioning</h2><p>The Prometheus CRD specification allows you to support arbitrary storage through a PersistentVolumeClaim.</p>
<p>The easiest way to use a volume that cannot be automatically provisioned (for whatever reason) is to use a label selector alongside a manually created PersistentVolume.</p>
<p>For example, using an NFS volume might be accomplished with the following specifications:</p>
<pre><code class="yaml">apiVersion: monitoring.coreos.com/v1
kind: Prometheus
metadata:
  name: my-example-prometheus-name
  labels:
    prometheus: example
spec:
  ...
  storage:
    volumeClaimTemplate:
      spec:
        selector:
          matchLabels:
            app: my-example-prometheus
        resources:
          requests:
            storage: 50Gi

---

apiVersion: v1
kind: PersistentVolume
metadata:
  name: my-pv-name
  labels:
    app: my-example-prometheus
spec:
  capacity:
    storage: 50Gi
  accessModes:
  - ReadWriteOnce # required
  nfs:
    server: myServer
    path: &quot;/path/to/prom/db&quot;</code></pre>
<h3 id="Disabling-Default-StorageClasses"><a href="#Disabling-Default-StorageClasses" class="headerlink" title="Disabling Default StorageClasses"></a>Disabling Default StorageClasses</h3><p>To manually provision volumes (as of Kubernetes 1.6.0), you may need to disable the default StorageClass that is automatically created for certain Cloud Providers. Default StorageClasses are pre-installed on Azure, AWS, GCE, OpenStack, and vSphere.</p>
<p>The default StorageClass behavior will override manual storage provisioning, preventing PersistentVolumeClaims from automatically binding to manually created PersistentVolumes.</p>
<p>To override this behavior, you must explicitly create the same resource, but set it to <em>not</em> be default. (See the <a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG.md#volumes">changelog</a> for more information.)</p>
<p>For example, to disable default StorageClasses on a Google Container Engine cluster, create the following StorageClass:</p>
<pre><code class="yaml">kind: StorageClass
apiVersion: storage.k8s.io/v1beta1
metadata:
  name: standard
  annotations:
    # disable this default storage class by setting this annotation to false.
    storageclass.beta.kubernetes.io/is-default-class: &quot;false&quot;
provisioner: kubernetes.io/gce-pd
parameters:
  type: pd-ssd
  zone: us-east1-d</code></pre>
